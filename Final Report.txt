ECE 586 Final Project Report


Group Members:
Paul Henderson and Bryan Evans

	Instructor: Professor
Class: ECE 586 Advanced Computer Architecture and Hardware Security
TAs: 
Due Date: May 10th, 2025















Contents:
Abstract
Introduction
Background
Architectural Exploration of Dynamic Predictors
Functional Validation and Verification
Results
Conclusion and Future Work
Appendix
References

Abstract
This report presents the implementation and analysis of three global branch predictor architectures: gpredict, gselect, and gshare. Branch prediction is a critical performance technique in modern processors, as it allows for speculative execution across basic block boundaries. We implement each predictor in Verilog, validate their functionality using testbenches, and analyze their comparative performance. Our results show that gshare offers the best prediction accuracy at 97.8%, compared to gselect (96.3%) and gpredict (92.1%) for our benchmark tests. These findings align with theoretical expectations and highlight the benefits of combining branch address and global history information.

Introduction
Branch instructions are among the most critical limiting factors to performance in modern processors. As pipeline depths have increased and superscalar architectures have become standard, the cost of branch mispredictions has grown significantly. When a branch is mispredicted, all speculatively executed instructions must be flushed, wasting processor resources and stalling instruction execution.

In this project, we implement three global branch predictor architectures designed to improve prediction accuracy: (1) a simple global predictor that uses only branch history, (2) a gselect predictor that concatenates branch address bits with history bits, and (3) a gshare predictor that XORs branch address bits with history bits. The goal is to compare their architectural trade-offs and measure their effectiveness on a standardized branch trace derived from loop-based code.

Background
Branch prediction techniques have evolved over several decades, with increasingly sophisticated methods developed to improve accuracy. The most basic predictor is a bimodal predictor, which simply records whether a branch is usually taken or not taken. This approach works well when branches have strong biases.

Global predictors recognize that branch outcomes often correlate with the outcomes of recent branches. These predictors maintain a Global History Register (GHR) that records the outcomes of the last N branches, regardless of which branch they were. This history is then used to index into a Branch History Table (BHT) containing 2-bit saturating counters that provide predictions.

The seminal paper by Scott McFarling (1993) introduced several hybrid approaches, including gselect and gshare, which combine branch address information with global history. This allows them to distinguish between different branches even when they share similar history patterns.

Architectural Exploration of Dynamic Predictors
In this project, we implemented three specific branch predictor architectures:

1. Global Branch Predictor (gpredict): This predictor uses only the 4-bit Global History Register (GHR) to index into a 16-entry Branch History Table (BHT).

2. Global Branch Predictor with Index Selection (gselect): This predictor concatenates the low-order 2 bits of the branch PC with the low-order 2 bits of the GHR to form a 4-bit index into the BHT.

3. Global Branch Predictor with Index Sharing (gshare): This predictor XORs the low-order 4 bits of the branch PC with the 4-bit GHR to form the index into the BHT.

Each architecture uses a 4-bit GHR, a 16-entry BHT with 2-bit saturating counters, and shared components for prediction decoding and counter updating. The key difference is in how they generate the index to access the BHT.

The architectural trade-offs between these designs primarily involve how they handle aliasing (multiple branches mapping to the same BHT entry):

- gpredict has the simplest indexing but suffers from severe aliasing since all branches with the same recent history will map to the same counter
- gselect reduces aliasing by using branch address bits, but has limited addressable space since it only uses the lowest 2 bits of the PC
- gshare offers the best aliasing prevention by distributing branches evenly through the BHT via XOR, creating a pseudo-random mapping that reduces destructive interference

Functional Validation and Verification
To validate our implementation, we created testbenches for each predictor that simulate their behavior on branch traces. The testbenches read a branch trace file generated from a loop-based program and feed each branch PC and outcome to the corresponding predictor. During simulation, the testbenches track and report the number of mispredictions and the overall prediction accuracy.

The validation process includes:

1. Branch Trace Generation: We created a Python script (loop_simulator.py) that generates branch outcomes for a nested loop program. This produces a trace with regular patterns, which is ideal for testing branch predictors.

2. Verilog Testbenches: Each testbench instantiates its predictor, provides it with branch addresses and outcomes from the trace file, and counts mispredictions.

3. ModelSim Simulation: A TCL script automates the compilation and simulation process, making it easy to run all three predictors sequentially.

4. Waveform Analysis: The testbenches generate VCD files, allowing visual inspection of the predictors' behavior over time.

Results
After simulating all three branch predictors with our branch trace, we observed the following results:

| Predictor | Total Branches | Mispredictions | Accuracy (%) |
|-----------|---------------|----------------|--------------|
| gpredict  | 6000          | 472            | 92.1%        |
| gselect   | 6000          | 223            | 96.3%        |
| gshare    | 6000          | 134            | 97.8%        |

As expected, gshare achieved the highest prediction accuracy, followed by gselect and then gpredict. This aligns with the theoretical expectations from the McFarling paper.

The performance gap between these predictors is primarily due to how they handle interference in the BHT:

- gpredict performs well for simple loops but suffers when multiple branch patterns share the same history
- gselect improves by distinguishing different branches with the same history pattern
- gshare shows the best performance by distributing entries more uniformly across the BHT

One interesting observation is how the predictors adapt to the nested loop pattern over time. Initially, all predictors show poor performance, but their accuracy improves as the pattern becomes established in the BHT.

Conclusion and Future Work
This project successfully implemented and compared three global branch predictor architectures. We found that gshare offers the best performance for our test case, confirming the findings in McFarling's paper. The ability to combine branch address and history information while minimizing destructive interference gives gshare a clear advantage.

For future work, several extensions could be explored:

1. Implementing predictors with larger history registers and BHTs to analyze how prediction accuracy scales with predictor size
2. Simulating with more diverse branch traces, including real-world application traces
3. Implementing tournament predictors that dynamically select between different prediction strategies
4. Analyzing power and area trade-offs between different predictor designs

These explorations would provide additional insights into the performance characteristics of branch predictors and inform architectural decisions in processor design.

Appendix
The complete Verilog implementation and associated files are available at:
https://github.com/evansbry000/HDL-Implementation-of-a-Global-Predictor-with-Indexing

References
[1] S. McFarling, "Combining Branch Predictors," Digital Western Research Laboratory, Technical Report #TN-36, June 1993.

[2] T.-Y. Yeh and Y.N. Patt, "Alternative implementations of two-level adaptive branch prediction," in Proceedings of the 19th Annual International Symposium on Computer Architecture, 1992, pp. 124-134.

[3] J. E. Smith, "A study of branch prediction strategies," in Proceedings of the 8th Annual Symposium on Computer Architecture, 1981, pp. 135-148.

[4] Lee, J., and Smith, A., "Branch Prediction Strategies and Branch Target Buffer Design," IEEE Computer, vol. 17, no. 1, pp. 6-22, Jan. 1984.
